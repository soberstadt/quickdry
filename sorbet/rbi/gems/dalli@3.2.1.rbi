# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dalli` gem.
# Please instead update this file by running `bin/tapioca gem dalli`.

module Dalli
  class << self
    def default_logger; end
    def logger; end
    def logger=(logger); end
    def rails_logger; end
  end
end

class Dalli::Client
  def initialize(servers = T.unsafe(nil), options = T.unsafe(nil)); end

  def add(key, value, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def alive!; end
  def append(key, value); end
  def cache_nils; end
  def cas(key, ttl = T.unsafe(nil), req_options = T.unsafe(nil), &block); end
  def cas!(key, ttl = T.unsafe(nil), req_options = T.unsafe(nil), &block); end
  def close; end
  def decr(key, amt = T.unsafe(nil), ttl = T.unsafe(nil), default = T.unsafe(nil)); end
  def delete(key); end
  def delete_cas(key, cas = T.unsafe(nil)); end
  def fetch(key, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def flush(delay = T.unsafe(nil)); end
  def flush_all(delay = T.unsafe(nil)); end
  def gat(key, ttl = T.unsafe(nil)); end
  def get(key, req_options = T.unsafe(nil)); end
  def get_cas(key); end
  def get_multi(*keys); end
  def get_multi_cas(*keys); end
  def incr(key, amt = T.unsafe(nil), ttl = T.unsafe(nil), default = T.unsafe(nil)); end
  def multi; end
  def not_found?(val); end
  def prepend(key, value); end
  def quiet; end
  def replace(key, value, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def replace_cas(key, value, cas, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def reset; end
  def reset_stats; end
  def set(key, value, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def set_cas(key, value, cas, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def stats(type = T.unsafe(nil)); end
  def touch(key, ttl = T.unsafe(nil)); end
  def version; end
  def with; end

  private

  def cas_core(key, always_set, ttl = T.unsafe(nil), req_options = T.unsafe(nil)); end
  def check_positive!(amt); end
  def normalize_options(opts); end
  def perform(*all_args); end
  def pipelined_getter; end
  def protocol_implementation; end
  def ring; end
  def ttl_or_default(ttl); end
end

Dalli::Client::ALLOWED_STAT_KEYS = T.let(T.unsafe(nil), Array)
Dalli::Client::CACHE_NILS = T.let(T.unsafe(nil), Hash)

class Dalli::Compressor
  class << self
    def compress(data); end
    def decompress(data); end
  end
end

class Dalli::DalliError < ::RuntimeError; end

class Dalli::GzipCompressor
  class << self
    def compress(data); end
    def decompress(data); end
  end
end

class Dalli::KeyManager
  def initialize(client_options); end

  def digest_class; end
  def key_with_namespace(key); end
  def key_without_namespace(key); end
  def namespace; end
  def namespace_from_options; end
  def namespace_regexp; end
  def prefix_length(digest); end
  def truncated_key(key); end
  def validate_digest_class_option(opts); end
  def validate_key(key); end
end

Dalli::KeyManager::DEFAULTS = T.let(T.unsafe(nil), Hash)
Dalli::KeyManager::MAX_KEY_LENGTH = T.let(T.unsafe(nil), Integer)
Dalli::KeyManager::NAMESPACE_SEPARATOR = T.let(T.unsafe(nil), String)
Dalli::KeyManager::OPTIONS = T.let(T.unsafe(nil), Array)
Dalli::KeyManager::TRUNCATED_KEY_SEPARATOR = T.let(T.unsafe(nil), String)
Dalli::KeyManager::TRUNCATED_KEY_TARGET_SIZE = T.let(T.unsafe(nil), Integer)
Dalli::MIN_SUPPORTED_MEMCACHED_VERSION = T.let(T.unsafe(nil), String)
class Dalli::MarshalError < ::Dalli::DalliError; end
Dalli::NOT_FOUND = T.let(T.unsafe(nil), Dalli::NilObject)
class Dalli::NetworkError < ::Dalli::DalliError; end
class Dalli::NilObject; end
class Dalli::NotPermittedMultiOpError < ::Dalli::DalliError; end

class Dalli::PipelinedGetter
  def initialize(ring, key_manager); end

  def abort_with_timeout(servers); end
  def abort_without_timeout(servers); end
  def fetch_responses(servers, start_time, timeout, &block); end
  def finish_queries(servers); end
  def finish_query_for_server(server); end
  def groups_for_keys(*keys); end
  def make_getkq_requests(groups); end
  def process(keys, &block); end
  def process_server(server); end
  def remaining_time(start, timeout); end
  def servers_with_response(servers, timeout); end
  def setup_requests(keys); end
end

module Dalli::Protocol; end

class Dalli::Protocol::Base
  extend ::Forwardable

  def initialize(attribs, client_options = T.unsafe(nil)); end

  def alive?; end
  def close(*args, **_arg1, &block); end
  def compress_by_default?(*args, **_arg1, &block); end
  def compression_min_size(*args, **_arg1, &block); end
  def compressor(*args, **_arg1, &block); end
  def connected?(*args, **_arg1, &block); end
  def down!(*args, **_arg1, &block); end
  def hostname(*args, **_arg1, &block); end
  def lock!; end
  def multi?; end
  def name(*args, **_arg1, &block); end
  def options; end
  def options=(_arg0); end
  def password; end
  def pipeline_abort; end
  def pipeline_complete?; end
  def pipeline_next_responses; end
  def pipeline_response_setup; end
  def port(*args, **_arg1, &block); end
  def quiet?; end
  def raise_down_error(*args, **_arg1, &block); end
  def reconnect_down_server?(*args, **_arg1, &block); end
  def request(opkey, *args); end
  def require_auth?; end
  def serializer(*args, **_arg1, &block); end
  def sock(*args, **_arg1, &block); end
  def socket_timeout(*args, **_arg1, &block); end
  def socket_type(*args, **_arg1, &block); end
  def unlock!; end
  def up!(*args, **_arg1, &block); end
  def username; end
  def weight; end
  def weight=(_arg0); end
  def write(*args, **_arg1, &block); end

  private

  def cache_nils?(opts); end
  def connect; end
  def ensure_connected!; end
  def finish_pipeline; end
  def log_marshal_err(key, err); end
  def log_unexpected_err(err); end
  def pipelined_get(keys); end
  def reconnect_on_pipeline_complete!; end
  def response_buffer; end
  def verify_allowed_quiet!(opkey); end
  def verify_state(opkey); end
end

Dalli::Protocol::Base::ALLOWED_QUIET_OPS = T.let(T.unsafe(nil), Array)

class Dalli::Protocol::Binary < ::Dalli::Protocol::Base
  include ::Dalli::Protocol::Binary::SaslAuthentication

  def response_processor; end

  private

  def add(key, value, ttl, options); end
  def append(key, value); end
  def cas(key); end
  def decr(key, count, ttl, initial); end
  def decr_incr(opkey, key, count, ttl, initial); end
  def delete(key, cas); end
  def flush(ttl = T.unsafe(nil)); end
  def gat(key, ttl, options = T.unsafe(nil)); end
  def get(key, options = T.unsafe(nil)); end
  def incr(key, count, ttl, initial); end
  def noop; end
  def prepend(key, value); end
  def quiet_get_request(key); end
  def replace(key, value, ttl, cas, options); end
  def reset_stats; end
  def set(key, value, ttl, cas, options); end
  def stats(info = T.unsafe(nil)); end
  def storage_req(opkey, key, value, ttl, cas, options); end
  def touch(key, ttl); end
  def version; end
  def write_append_prepend(opkey, key, value); end
  def write_noop; end
end

Dalli::Protocol::Binary::NOT_FOUND_EXPIRY = T.let(T.unsafe(nil), Integer)

class Dalli::Protocol::Binary::RequestFormatter
  class << self
    def as_8byte_uint(val); end
    def decr_incr_request(opkey:, key: T.unsafe(nil), count: T.unsafe(nil), initial: T.unsafe(nil), expiry: T.unsafe(nil)); end
    def standard_request(opkey:, key: T.unsafe(nil), value: T.unsafe(nil), opaque: T.unsafe(nil), cas: T.unsafe(nil), bitflags: T.unsafe(nil), ttl: T.unsafe(nil)); end
  end
end

Dalli::Protocol::Binary::RequestFormatter::BODY_FORMATS = T.let(T.unsafe(nil), Hash)
Dalli::Protocol::Binary::RequestFormatter::FORMAT = T.let(T.unsafe(nil), Hash)
Dalli::Protocol::Binary::RequestFormatter::INCR_DECR = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::RequestFormatter::KEY_AND_VALUE = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::RequestFormatter::KEY_ONLY = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::RequestFormatter::NO_BODY = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::RequestFormatter::OPCODES = T.let(T.unsafe(nil), Hash)
Dalli::Protocol::Binary::RequestFormatter::REQUEST = T.let(T.unsafe(nil), Integer)
Dalli::Protocol::Binary::RequestFormatter::REQ_HEADER_FORMAT = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::RequestFormatter::TTL_AND_KEY = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::RequestFormatter::TTL_ONLY = T.let(T.unsafe(nil), String)

class Dalli::Protocol::Binary::ResponseHeader
  def initialize(buf); end

  def body_len; end
  def cas; end
  def data_type; end
  def extra_len; end
  def key_len; end
  def not_found?; end
  def not_stored?; end
  def ok?; end
  def opaque; end
  def status; end
end

Dalli::Protocol::Binary::ResponseHeader::FMT = T.let(T.unsafe(nil), String)
Dalli::Protocol::Binary::ResponseHeader::NOT_STORED_STATUSES = T.let(T.unsafe(nil), Array)
Dalli::Protocol::Binary::ResponseHeader::SIZE = T.let(T.unsafe(nil), Integer)

class Dalli::Protocol::Binary::ResponseProcessor
  def initialize(io_source, value_marshaller); end

  def auth_response(buf = T.unsafe(nil)); end
  def consume_all_responses_until_noop; end
  def contains_header?(buf); end
  def data_cas_response; end
  def decr_incr; end
  def delete; end
  def flush; end
  def generic_response; end
  def get(cache_nils: T.unsafe(nil)); end
  def getk_response_from_buffer(buf); end
  def no_body_response; end
  def raise_on_not_ok!(resp_header); end
  def read(num_bytes); end
  def read_header; end
  def read_response; end
  def reset; end
  def response_header_from_buffer(buf); end
  def stats; end
  def storage_response; end
  def unpack_response_body(resp_header, body, parse_as_stored_value); end
  def validate_auth_format(extra_len, count); end
  def version; end
end

Dalli::Protocol::Binary::ResponseProcessor::RESPONSE_CODES = T.let(T.unsafe(nil), Hash)

module Dalli::Protocol::Binary::SaslAuthentication
  def authenticate_connection; end
  def authenticate_with_plain; end
  def perform_auth_negotiation; end
  def supported_mechanisms!(mechanisms); end
end

Dalli::Protocol::Binary::SaslAuthentication::PLAIN_AUTH = T.let(T.unsafe(nil), String)

class Dalli::Protocol::ConnectionManager
  def initialize(hostname, port, socket_type, client_options); end

  def abort_request!; end
  def close; end
  def close_on_fork; end
  def confirm_ready!; end
  def connected?; end
  def down!; end
  def error_on_request!(err_or_string); end
  def establish_connection; end
  def finish_request!; end
  def fork_detected?; end
  def hostname; end
  def hostname=(_arg0); end
  def log_down_detected; end
  def log_up_detected; end
  def log_warn_message(err_or_string); end
  def max_allowed_failures; end
  def memcached_socket; end
  def name; end
  def options; end
  def options=(_arg0); end
  def port; end
  def port=(_arg0); end
  def raise_down_error; end
  def read(count); end
  def read_line; end
  def read_nonblock; end
  def reconnect!(message); end
  def reconnect_down_server?; end
  def request_in_progress?; end
  def reset_down_info; end
  def sock; end
  def socket_timeout; end
  def socket_type; end
  def socket_type=(_arg0); end
  def start_request!; end
  def up!; end
  def write(bytes); end
end

Dalli::Protocol::ConnectionManager::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Dalli::Protocol::Meta < ::Dalli::Protocol::Base
  def response_processor; end

  private

  def add(key, value, ttl, options); end
  def append(key, value); end
  def authenticate_connection; end
  def cas(key); end
  def decr(key, count, ttl, initial); end
  def decr_incr(incr, key, delta, ttl, initial); end
  def delete(key, cas); end
  def flush(delay = T.unsafe(nil)); end
  def gat(key, ttl, options = T.unsafe(nil)); end
  def get(key, options = T.unsafe(nil)); end
  def incr(key, count, ttl, initial); end
  def noop; end
  def prepend(key, value); end
  def quiet_get_request(key); end
  def replace(key, value, ttl, cas, options); end
  def reset_stats; end
  def set(key, value, ttl, cas, options); end
  def stats(info = T.unsafe(nil)); end
  def touch(key, ttl); end
  def version; end
  def write_append_prepend_req(mode, key, value, ttl = T.unsafe(nil), cas = T.unsafe(nil), _options = T.unsafe(nil)); end
  def write_noop; end
  def write_storage_req(mode, key, raw_value, ttl = T.unsafe(nil), cas = T.unsafe(nil), options = T.unsafe(nil)); end
end

class Dalli::Protocol::Meta::KeyRegularizer
  class << self
    def decode(encoded_key, base64_encoded); end
    def encode(key); end
  end
end

Dalli::Protocol::Meta::KeyRegularizer::WHITESPACE = T.let(T.unsafe(nil), Regexp)

class Dalli::Protocol::Meta::RequestFormatter
  class << self
    def flush(delay: T.unsafe(nil), quiet: T.unsafe(nil)); end
    def meta_arithmetic(key:, delta:, initial:, incr: T.unsafe(nil), cas: T.unsafe(nil), ttl: T.unsafe(nil), base64: T.unsafe(nil), quiet: T.unsafe(nil)); end
    def meta_delete(key:, cas: T.unsafe(nil), ttl: T.unsafe(nil), base64: T.unsafe(nil), quiet: T.unsafe(nil)); end
    def meta_get(key:, value: T.unsafe(nil), return_cas: T.unsafe(nil), ttl: T.unsafe(nil), base64: T.unsafe(nil), quiet: T.unsafe(nil)); end
    def meta_noop; end
    def meta_set(key:, value:, bitflags: T.unsafe(nil), cas: T.unsafe(nil), ttl: T.unsafe(nil), mode: T.unsafe(nil), base64: T.unsafe(nil), quiet: T.unsafe(nil)); end
    def mode_to_token(mode); end
    def stats(arg = T.unsafe(nil)); end
    def version; end
  end
end

class Dalli::Protocol::Meta::ResponseProcessor
  def initialize(io_source, value_marshaller); end

  def bitflags_from_tokens(tokens); end
  def body_len_from_tokens(tokens); end
  def cas_from_tokens(tokens); end
  def consume_all_responses_until_mn; end
  def contains_header?(buf); end
  def decr_incr; end
  def error_on_unexpected!(expected_codes); end
  def flush; end
  def full_response_from_buffer(tokens, body, resp_size); end
  def getk_response_from_buffer(buf); end
  def header_from_buffer(buf); end
  def key_from_tokens(tokens); end
  def meta_delete; end
  def meta_get_with_value(cache_nils: T.unsafe(nil)); end
  def meta_get_with_value_and_cas; end
  def meta_get_without_value; end
  def meta_set_append_prepend; end
  def meta_set_with_cas; end
  def next_line_to_tokens; end
  def read_line; end
  def reset; end
  def stats; end
  def tokens_from_header_buffer(buf); end
  def value_from_tokens(tokens, flag); end
  def version; end
end

Dalli::Protocol::Meta::ResponseProcessor::EN = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::END_TOKEN = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::EX = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::HD = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::MN = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::NF = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::NS = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::OK = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::RESET = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::STAT = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::VA = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::ResponseProcessor::VERSION = T.let(T.unsafe(nil), String)
Dalli::Protocol::Meta::TERMINATOR = T.let(T.unsafe(nil), String)
Dalli::Protocol::NOT_FOUND = T.let(T.unsafe(nil), Dalli::NilObject)

class Dalli::Protocol::ResponseBuffer
  def initialize(io_source, response_processor); end

  def advance(bytes_to_advance); end
  def clear; end
  def in_progress?; end
  def process_single_getk_response; end
  def read; end
  def reset; end
end

class Dalli::Protocol::ServerConfigParser
  class << self
    def attributes_for_tcp_socket(res); end
    def attributes_for_unix_socket(res); end
    def deconstruct_string(str); end
    def normalize_host_from_match(str, res); end
    def normalize_port(port); end
    def normalize_weight(weight); end
    def parse(str); end
    def parse_non_uri(str); end
    def parse_uri(str); end
  end
end

Dalli::Protocol::ServerConfigParser::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Dalli::Protocol::ServerConfigParser::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)
Dalli::Protocol::ServerConfigParser::MEMCACHED_URI_PROTOCOL = T.let(T.unsafe(nil), String)
Dalli::Protocol::ServerConfigParser::SERVER_CONFIG_REGEXP = T.let(T.unsafe(nil), Regexp)

class Dalli::Protocol::TtlSanitizer
  class << self
    def as_timestamp(ttl_as_i); end
    def current_timestamp; end
    def less_than_max_expiration_interval?(ttl_as_i); end
    def sanitize(ttl); end
  end
end

Dalli::Protocol::TtlSanitizer::MAX_ACCEPTABLE_EXPIRATION_INTERVAL = T.let(T.unsafe(nil), Integer)

class Dalli::Protocol::ValueCompressor
  def initialize(client_options); end

  def compress_by_default?; end
  def compress_value?(value, req_options); end
  def compression_min_size; end
  def compressor; end
  def retrieve(value, bitflags); end
  def store(value, req_options, bitflags); end
end

Dalli::Protocol::ValueCompressor::DEFAULTS = T.let(T.unsafe(nil), Hash)
Dalli::Protocol::ValueCompressor::FLAG_COMPRESSED = T.let(T.unsafe(nil), Integer)
Dalli::Protocol::ValueCompressor::OPTIONS = T.let(T.unsafe(nil), Array)

class Dalli::Protocol::ValueMarshaller
  extend ::Forwardable

  def initialize(client_options); end

  def compress_by_default?(*args, **_arg1, &block); end
  def compression_min_size(*args, **_arg1, &block); end
  def compressor(*args, **_arg1, &block); end
  def error_if_over_max_value_bytes(key, value); end
  def retrieve(value, flags); end
  def serializer(*args, **_arg1, &block); end
  def store(key, value, options = T.unsafe(nil)); end
  def value_max_bytes; end
end

Dalli::Protocol::ValueMarshaller::DEFAULTS = T.let(T.unsafe(nil), Hash)
Dalli::Protocol::ValueMarshaller::OPTIONS = T.let(T.unsafe(nil), Array)

class Dalli::Protocol::ValueSerializer
  def initialize(protocol_options); end

  def filter_argument_error(err); end
  def filter_name_error(err); end
  def filter_type_error(err); end
  def retrieve(value, bitflags); end
  def serialization_options; end
  def serialization_options=(_arg0); end
  def serialize_value(value); end
  def serializer; end
  def store(value, req_options, bitflags); end
end

Dalli::Protocol::ValueSerializer::ARGUMENT_ERR_REGEXP = T.let(T.unsafe(nil), Regexp)
Dalli::Protocol::ValueSerializer::DEFAULTS = T.let(T.unsafe(nil), Hash)
Dalli::Protocol::ValueSerializer::FLAG_SERIALIZED = T.let(T.unsafe(nil), Integer)
Dalli::Protocol::ValueSerializer::NAME_ERR_STR = T.let(T.unsafe(nil), String)
Dalli::Protocol::ValueSerializer::OPTIONS = T.let(T.unsafe(nil), Array)
Dalli::Protocol::ValueSerializer::TYPE_ERR_REGEXP = T.let(T.unsafe(nil), Regexp)
Dalli::QUIET = T.let(T.unsafe(nil), Symbol)

class Dalli::Ring
  def initialize(servers_arg, protocol_implementation, options); end

  def close; end
  def continuum; end
  def continuum=(_arg0); end
  def keys_grouped_by_server(key_arr); end
  def lock; end
  def pipeline_consume_and_ignore_responses; end
  def server_for_key(key); end
  def server_from_continuum(key); end
  def servers; end
  def servers=(_arg0); end
  def socket_timeout; end

  private

  def build_continuum(servers); end
  def entry_count_for(server, total_servers, total_weight); end
  def hash_for(key); end
  def server_for_hash_key(hash_key); end
  def threadsafe!; end
end

class Dalli::Ring::Entry
  def initialize(val, srv); end

  def server; end
  def value; end
end

Dalli::Ring::POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)
class Dalli::RingError < ::Dalli::DalliError; end
Dalli::Server = Dalli::Protocol::Binary

module Dalli::ServersArgNormalizer
  class << self
    def apply_defaults(arg); end
    def normalize_servers(arg); end
    def validate_type(arg); end
  end
end

Dalli::ServersArgNormalizer::DEFAULT_SERVERS = T.let(T.unsafe(nil), Array)
Dalli::ServersArgNormalizer::ENV_VAR_NAME = T.let(T.unsafe(nil), String)
module Dalli::Socket; end

module Dalli::Socket::InstanceMethods
  def append_to_buffer?(result); end
  def logged_options; end
  def nonblock_timed_out?(result); end
  def read_available; end
  def readfull(count); end
end

Dalli::Socket::InstanceMethods::FILTERED_OUT_OPTIONS = T.let(T.unsafe(nil), Array)
Dalli::Socket::InstanceMethods::WAIT_RCS = T.let(T.unsafe(nil), Array)

class Dalli::Socket::SSLSocket < ::OpenSSL::SSL::SSLSocket
  include ::Dalli::Socket::InstanceMethods

  def options; end
  def wait_readable(timeout = T.unsafe(nil)); end
  def wait_writable(timeout = T.unsafe(nil)); end
end

class Dalli::Socket::TCP < ::TCPSocket
  include ::Dalli::Socket::InstanceMethods

  def options; end
  def options=(_arg0); end

  class << self
    def init_socket_options(sock, options); end
    def open(host, port, options = T.unsafe(nil)); end
    def wrapping_ssl_socket(tcp_socket, host, ssl_context); end
  end
end

class Dalli::Socket::UNIX < ::UNIXSocket
  include ::Dalli::Socket::InstanceMethods

  def options; end
  def options=(_arg0); end

  class << self
    def open(path, options = T.unsafe(nil)); end
  end
end

module Dalli::Threadsafe
  def alive?; end
  def close; end
  def init_threadsafe; end
  def lock!; end
  def pipeline_abort; end
  def pipeline_next_responses; end
  def pipeline_response_setup; end
  def request(opcode, *args); end
  def unlock!; end

  class << self
    def extended(obj); end
  end
end

class Dalli::UnmarshalError < ::Dalli::DalliError; end
Dalli::VERSION = T.let(T.unsafe(nil), String)
class Dalli::ValueOverMaxSize < ::Dalli::DalliError; end
