# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-mini-profiler` gem.
# Please instead update this file by running `bin/tapioca gem rack-mini-profiler`.

# typed: true

class PG::Connection
  include ::PG::Constants

  def initialize(*_arg0); end

  def async_describe_portal(_arg0); end
  def async_describe_prepared(_arg0); end
  def async_exec(*args, &blk); end
  def async_exec_params(*_arg0); end
  def async_exec_prepared(*_arg0); end
  def async_exec_without_profiling(*_arg0); end
  def async_prepare(*_arg0); end
  def async_query(*_arg0); end
  def backend_pid; end
  def block(*_arg0); end
  def cancel; end
  def client_encoding=(_arg0); end
  def close; end
  def conndefaults; end
  def conndefaults_hash; end
  def connect_poll; end
  def connection_needs_password; end
  def connection_used_password; end
  def conninfo; end
  def conninfo_hash; end
  def consume_input; end
  def copy_data(sql, coder = T.unsafe(nil)); end
  def db; end
  def decoder_for_get_copy_data; end
  def decoder_for_get_copy_data=(_arg0); end
  def describe_portal(_arg0); end
  def describe_prepared(_arg0); end
  def discard_results; end
  def encoder_for_put_copy_data; end
  def encoder_for_put_copy_data=(_arg0); end
  def encrypt_password(*_arg0); end
  def error_message; end
  def escape(_arg0); end
  def escape_bytea(_arg0); end
  def escape_identifier(_arg0); end
  def escape_literal(_arg0); end
  def escape_string(_arg0); end
  def exec(*args, &blk); end
  def exec_params(*args, &blk); end
  def exec_params_without_profiling(*_arg0); end
  def exec_prepared(*args, &blk); end
  def exec_prepared_without_profiling(*_arg0); end
  def exec_without_profiling(*_arg0); end
  def external_encoding; end
  def field_name_type; end
  def field_name_type=(_arg0); end
  def finish; end
  def finished?; end
  def flush; end
  def get_client_encoding; end
  def get_copy_data(*_arg0); end
  def get_last_result; end
  def get_result; end
  def host; end
  def internal_encoding; end
  def internal_encoding=(_arg0); end
  def is_busy; end
  def isnonblocking; end
  def lo_close(_arg0); end
  def lo_creat(*_arg0); end
  def lo_create(_arg0); end
  def lo_export(_arg0, _arg1); end
  def lo_import(_arg0); end
  def lo_lseek(_arg0, _arg1, _arg2); end
  def lo_open(*_arg0); end
  def lo_read(_arg0, _arg1); end
  def lo_seek(_arg0, _arg1, _arg2); end
  def lo_tell(_arg0); end
  def lo_truncate(_arg0, _arg1); end
  def lo_unlink(_arg0); end
  def lo_write(_arg0, _arg1); end
  def loclose(_arg0); end
  def locreat(*_arg0); end
  def locreate(_arg0); end
  def loexport(_arg0, _arg1); end
  def loimport(_arg0); end
  def lolseek(_arg0, _arg1, _arg2); end
  def loopen(*_arg0); end
  def loread(_arg0, _arg1); end
  def loseek(_arg0, _arg1, _arg2); end
  def lotell(_arg0); end
  def lotruncate(_arg0, _arg1); end
  def lounlink(_arg0); end
  def lowrite(_arg0, _arg1); end
  def make_empty_pgresult(_arg0); end
  def nonblocking?; end
  def notifies; end
  def notifies_wait(*_arg0); end
  def options; end
  def parameter_status(_arg0); end
  def pass; end
  def port; end
  def prepare(*args, &blk); end
  def prepare_without_profiling(*_arg0); end
  def protocol_version; end
  def put_copy_data(*_arg0); end
  def put_copy_end(*_arg0); end
  def query(*args, &blk); end
  def quote_ident(_arg0); end
  def reset; end
  def reset_poll; end
  def reset_start; end
  def send_describe_portal(_arg0); end
  def send_describe_prepared(_arg0); end
  def send_prepare(*_arg0); end
  def send_query(*_arg0); end
  def send_query_params(*_arg0); end
  def send_query_prepared(*args, &blk); end
  def send_query_prepared_without_profiling(*_arg0); end
  def server_version; end
  def set_client_encoding(_arg0); end
  def set_default_encoding; end
  def set_error_context_visibility(_arg0); end
  def set_error_verbosity(_arg0); end
  def set_notice_processor; end
  def set_notice_receiver; end
  def set_single_row_mode; end
  def setnonblocking(_arg0); end
  def socket; end
  def socket_io; end
  def ssl_attribute(_arg0); end
  def ssl_attribute_names; end
  def ssl_attributes; end
  def ssl_in_use?; end
  def status; end
  def sync_describe_portal(_arg0); end
  def sync_describe_prepared(_arg0); end
  def sync_exec(*_arg0); end
  def sync_exec_params(*_arg0); end
  def sync_exec_prepared(*_arg0); end
  def sync_prepare(*_arg0); end
  def trace(_arg0); end
  def transaction; end
  def transaction_status; end
  def tty; end
  def type_map_for_queries; end
  def type_map_for_queries=(_arg0); end
  def type_map_for_results; end
  def type_map_for_results=(_arg0); end
  def unescape_bytea(_arg0); end
  def untrace; end
  def user; end
  def wait_for_notify(*_arg0); end

  class << self
    def async_api=(enable); end
    def conndefaults; end
    def conndefaults_hash; end
    def connect(*_arg0); end
    def connect_start(*_arg0); end
    def encrypt_password(_arg0, _arg1); end
    def escape(_arg0); end
    def escape_bytea(_arg0); end
    def escape_string(_arg0); end
    def isthreadsafe; end
    def open(*_arg0); end
    def parse_connect_args(*args); end
    def ping(*_arg0); end
    def quote_connstr(value); end
    def quote_ident(_arg0); end
    def setdb(*_arg0); end
    def setdblogin(*_arg0); end
    def unescape_bytea(_arg0); end
  end
end

PG::Connection::CONNECT_ARGUMENT_ORDER = T.let(T.unsafe(nil), Array)
PG::Connection::REDIRECT_METHODS = T.let(T.unsafe(nil), Hash)

class PG::Result
  include ::Enumerable
  include ::PG::Constants

  def [](_arg0); end
  def autoclear?; end
  def check; end
  def check_result; end
  def clear; end
  def cleared?; end
  def cmd_status; end
  def cmd_tuples; end
  def cmdtuples; end
  def column_values(_arg0); end
  def each(*args, &blk); end
  def each_row; end
  def each_without_profiling; end
  def error_field(_arg0); end
  def error_message; end
  def fformat(_arg0); end
  def field_name_type; end
  def field_name_type=(_arg0); end
  def field_names_as(type); end
  def field_values(_arg0); end
  def fields; end
  def fmod(_arg0); end
  def fname(_arg0); end
  def fnumber(_arg0); end
  def fsize(_arg0); end
  def ftable(_arg0); end
  def ftablecol(_arg0); end
  def ftype(_arg0); end
  def getisnull(_arg0, _arg1); end
  def getlength(_arg0, _arg1); end
  def getvalue(_arg0, _arg1); end
  def inspect; end
  def map_types!(type_map); end
  def mp_report_sql(&block); end
  def nfields; end
  def nparams; end
  def ntuples; end
  def num_fields; end
  def num_tuples; end
  def oid_value; end
  def paramtype(_arg0); end
  def res_status(_arg0); end
  def result_error_field(_arg0); end
  def result_error_message; end
  def result_status; end
  def result_verbose_error_message(_arg0, _arg1); end
  def stream_each; end
  def stream_each_row; end
  def stream_each_tuple; end
  def tuple(_arg0); end
  def tuple_values(_arg0); end
  def type_map; end
  def type_map=(_arg0); end
  def values(*args, &blk); end
  def values_without_profiling; end
  def verbose_error_message(_arg0, _arg1); end
end

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler
  extend ::Rack::MiniProfiler::ProfilingMethods

  def initialize(app, config = T.unsafe(nil)); end

  def advanced_debugging_enabled?; end
  def analyze_memory; end
  def cache_control_value; end
  def call(env); end
  def cancel_auto_inject(env); end
  def config; end
  def current; end
  def current=(c); end
  def dump_env(env); end
  def dump_exceptions(exceptions); end
  def flamegraph(graph, path); end
  def generate_html(page_struct, env, result_json = T.unsafe(nil)); end
  def get_profile_script(env); end
  def help(client_settings, env); end
  def ids(env); end
  def ids_comma_separated(env); end
  def inject(fragment, script); end
  def inject_profiler(env, status, headers, body); end
  def make_link(postfix, env); end
  def serve_html(env); end
  def serve_results(env); end
  def text_result(body); end
  def tool_disabled_message(client_settings); end
  def trim_strings(strings, max_size); end
  def user(env); end

  private

  def handle_snapshots_request(env); end
  def rails_route_from_path(path, method); end
  def serve_flamegraph(env); end
  def take_snapshot(env, start); end
  def take_snapshot?(path); end
  def url_for_snapshot(id); end
  def url_for_snapshots_group(group_name); end

  class << self
    def add_snapshot_custom_field(key, value); end
    def advanced_tools_message; end
    def authorize_request; end
    def binds_to_params(binds); end
    def config; end
    def create_current(env = T.unsafe(nil), options = T.unsafe(nil)); end
    def current; end
    def current=(c); end
    def deauthorize_request; end
    def discard_results; end
    def generate_id; end
    def get_snapshot_custom_fields; end
    def patch_rails?; end
    def redact_sql_queries?; end
    def request_authorized?; end
    def reset_config; end
    def resources_root; end
    def share_template; end
    def snapshots_transporter?; end
    def subscribe_sql_active_record; end
    def subscribe_sql_active_record=(_arg0); end
  end
end

Rack::MiniProfiler::ASSET_VERSION = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::AbstractStore
  def allowed_tokens; end
  def diagnostics(user); end
  def fetch_snapshots(batch_size: T.unsafe(nil), &blk); end
  def find_snapshots_group(group_name); end
  def get_unviewed_ids(user); end
  def load(id); end
  def load_snapshot(id); end
  def push_snapshot(page_struct, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
  def should_take_snapshot?(period); end
  def snapshot_groups_overview; end

  private

  def default_snapshot_grouping(snapshot); end
  def rails_route_from_path(path, method); end
end

Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::ClientSettings
  def initialize(env, store, start); end

  def backtrace_default?; end
  def backtrace_full?; end
  def backtrace_level; end
  def backtrace_level=(_arg0); end
  def backtrace_none?; end
  def disable_profiling; end
  def disable_profiling=(_arg0); end
  def disable_profiling?; end
  def discard_cookie!(headers); end
  def handle_cookie(result); end
  def has_valid_cookie?; end
  def write!(headers); end
end

Rack::MiniProfiler::ClientSettings::BACKTRACE_FULL = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::ClientSettings::BACKTRACE_NONE = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::ClientSettings::COOKIE_NAME = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::Config
  def assets_url; end
  def assets_url=(lmbda); end
  def authorization_mode; end
  def authorization_mode=(mode); end
  def auto_inject; end
  def auto_inject=(_arg0); end
  def backtrace_ignores; end
  def backtrace_ignores=(_arg0); end
  def backtrace_includes; end
  def backtrace_includes=(_arg0); end
  def backtrace_remove; end
  def backtrace_remove=(_arg0); end
  def backtrace_threshold_ms; end
  def backtrace_threshold_ms=(_arg0); end
  def base_url_path; end
  def base_url_path=(_arg0); end
  def collapse_results; end
  def collapse_results=(_arg0); end
  def content_security_policy_nonce; end
  def content_security_policy_nonce=(_arg0); end
  def disable_caching; end
  def disable_caching=(_arg0); end
  def enable_advanced_debugging_tools; end
  def enable_advanced_debugging_tools=(_arg0); end
  def enable_hotwire_turbo_drive_support; end
  def enable_hotwire_turbo_drive_support=(_arg0); end
  def enabled; end
  def enabled=(_arg0); end
  def flamegraph_mode; end
  def flamegraph_mode=(_arg0); end
  def flamegraph_sample_rate; end
  def flamegraph_sample_rate=(_arg0); end
  def horizontal_position; end
  def html_container; end
  def html_container=(_arg0); end
  def logger; end
  def logger=(_arg0); end
  def max_sql_param_length; end
  def max_sql_param_length=(_arg0); end
  def max_traces_to_show; end
  def max_traces_to_show=(_arg0); end
  def merge!(config); end
  def position; end
  def position=(_arg0); end
  def pre_authorize_cb; end
  def pre_authorize_cb=(_arg0); end
  def show_children; end
  def show_children=(_arg0); end
  def show_controls; end
  def show_controls=(_arg0); end
  def show_total_sql_count; end
  def show_total_sql_count=(_arg0); end
  def show_trivial; end
  def show_trivial=(_arg0); end
  def skip_paths; end
  def skip_paths=(_arg0); end
  def skip_schema_queries; end
  def skip_schema_queries=(_arg0); end
  def skip_sql_param_names; end
  def skip_sql_param_names=(_arg0); end
  def snapshot_every_n_requests; end
  def snapshot_every_n_requests=(_arg0); end
  def snapshot_hidden_custom_fields; end
  def snapshot_hidden_custom_fields=(_arg0); end
  def snapshots_limit; end
  def snapshots_limit=(_arg0); end
  def snapshots_redact_sql_queries; end
  def snapshots_redact_sql_queries=(_arg0); end
  def snapshots_transport_auth_key; end
  def snapshots_transport_auth_key=(_arg0); end
  def snapshots_transport_destination_url; end
  def snapshots_transport_destination_url=(_arg0); end
  def snapshots_transport_gzip_requests; end
  def snapshots_transport_gzip_requests=(_arg0); end
  def start_hidden; end
  def start_hidden=(_arg0); end
  def storage; end
  def storage=(_arg0); end
  def storage_failure; end
  def storage_failure=(_arg0); end
  def storage_instance; end
  def storage_instance=(_arg0); end
  def storage_options; end
  def storage_options=(_arg0); end
  def suppress_encoding; end
  def suppress_encoding=(_arg0); end
  def toggle_shortcut; end
  def toggle_shortcut=(_arg0); end
  def use_existing_jquery; end
  def use_existing_jquery=(_arg0); end
  def user_provider; end
  def user_provider=(_arg0); end
  def vertical_position; end

  class << self
    def attr_accessor(*vars); end
    def attributes; end
    def default; end
  end
end

class Rack::MiniProfiler::Context
  def initialize(opts = T.unsafe(nil)); end

  def current_timer; end
  def current_timer=(_arg0); end
  def discard; end
  def discard=(_arg0); end
  def full_backtrace; end
  def full_backtrace=(_arg0); end
  def inject_js; end
  def inject_js=(_arg0); end
  def measure; end
  def measure=(_arg0); end
  def mpt_init; end
  def mpt_init=(_arg0); end
  def page_struct; end
  def page_struct=(_arg0); end
  def skip_backtrace; end
  def skip_backtrace=(_arg0); end
end

class Rack::MiniProfiler::FileStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def cleanup_cache; end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
end

class Rack::MiniProfiler::FileStore::CacheCleanupThread < ::Thread; end
Rack::MiniProfiler::FileStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::FileStore::FileCache
  def initialize(path, prefix); end

  def [](key); end
  def []=(key, val); end

  private

  def path(key); end
end

class Rack::MiniProfiler::GCProfiler
  def initialize; end

  def analyze_growth(ids_before, ids_after); end
  def analyze_initial_state(ids_before); end
  def analyze_strings(ids_before, ids_after); end
  def diff_object_stats(before, after); end
  def object_space_stats; end
  def profile_gc(app, env); end
end

class Rack::MiniProfiler::MemcacheStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
end

Rack::MiniProfiler::MemcacheStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::MemcacheStore::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def cleanup_cache; end
  def fetch_snapshots(batch_size: T.unsafe(nil), &blk); end
  def get_unviewed_ids(user); end
  def initialize_cleanup_thread(args = T.unsafe(nil)); end
  def initialize_locks; end
  def load(id); end
  def load_snapshot(id); end
  def push_snapshot(page_struct, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
  def should_take_snapshot?(period); end

  private

  def wipe_snapshots_data; end
end

Rack::MiniProfiler::MemoryStore::CLEANUP_CYCLE = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::MemoryStore::CLEANUP_INTERVAL = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore::CacheCleanupThread < ::Thread
  def initialize(interval, cycle, store); end

  def cleanup; end
  def cycle_count; end
  def increment_cycle; end
  def should_cleanup?; end
  def sleepy_run; end
end

Rack::MiniProfiler::MemoryStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

module Rack::MiniProfiler::ProfilingMethods
  def counter(type, duration_ms = T.unsafe(nil)); end
  def counter_method(klass, method, &blk); end
  def finish_step(obj); end
  def profile_method(klass, method, type = T.unsafe(nil), &blk); end
  def profile_singleton_method(klass, method, type = T.unsafe(nil), &blk); end
  def record_sql(query, elapsed_ms, params = T.unsafe(nil)); end
  def start_step(name); end
  def step(name, opts = T.unsafe(nil)); end
  def uncounter_method(klass, method); end
  def unprofile_method(klass, method); end
  def unprofile_singleton_method(klass, method); end

  private

  def clean_method_name(method); end
end

class Rack::MiniProfiler::RedisStore < ::Rack::MiniProfiler::AbstractStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def diagnostics(user); end
  def fetch_snapshots(batch_size: T.unsafe(nil), &blk); end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def load_snapshot(id); end
  def prefix; end
  def push_snapshot(page_struct, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
  def should_take_snapshot?(period); end
  def simulate_expire; end

  private

  def cached_redis_eval(script, script_sha, reraise: T.unsafe(nil), argv: T.unsafe(nil), keys: T.unsafe(nil)); end
  def prefixed_id(id); end
  def redis; end
  def snapshot_counter_key; end
  def snapshot_hash_key; end
  def snapshot_zset_key; end
  def user_key(user); end
  def wipe_snapshots_data; end
end

Rack::MiniProfiler::RedisStore::COUNTER_LUA = T.let(T.unsafe(nil), String)
Rack::MiniProfiler::RedisStore::COUNTER_LUA_SHA = T.let(T.unsafe(nil), String)
Rack::MiniProfiler::RedisStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::SOURCE_CODE_URI = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::SnapshotsTransporter
  def initialize(config); end

  def buffer; end
  def flush_buffer; end
  def gzip_requests; end
  def gzip_requests=(_arg0); end
  def max_buffer_size; end
  def max_buffer_size=(_arg0); end
  def requests_interval; end
  def ship(snapshot); end

  private

  def backoff_delay; end
  def start_thread; end

  class << self
    def failed_http_requests_count; end
    def successful_http_requests_count; end
    def transport(snapshot); end
    def transported_snapshots_count; end
  end
end

module Rack::MiniProfiler::TimerStruct; end

class Rack::MiniProfiler::TimerStruct::Base
  def initialize(attrs = T.unsafe(nil)); end

  def [](name); end
  def []=(name, val); end
  def as_json(options = T.unsafe(nil)); end
  def attributes; end
  def to_json(*a); end
end

class Rack::MiniProfiler::TimerStruct::Client < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(env = T.unsafe(nil)); end

  def redirect_count; end
  def timings; end

  class << self
    def init_from_form_data(env, page_struct); end
    def init_instrumentation; end
    def instrument(name, orig); end
  end
end

class Rack::MiniProfiler::TimerStruct::Custom < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(type, duration_ms, page, parent); end

  def parent; end
  def parent=(_arg0); end
end

class Rack::MiniProfiler::TimerStruct::Page < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(env); end

  def as_json(options = T.unsafe(nil)); end
  def attributes; end
  def attributes_to_serialize; end
  def duration_ms; end
  def duration_ms_in_sql; end
  def extra_json; end
  def name; end
  def root; end
  def to_json(*a); end

  class << self
    def from_hash(hash); end

    private

    def symbolize_array(array); end
    def symbolize_hash(hash); end
  end
end

class Rack::MiniProfiler::TimerStruct::Request < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(name, page, parent); end

  def add_child(name); end
  def add_custom(type, elapsed_ms, page); end
  def add_sql(query, elapsed_ms, page, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end
  def adjust_depth; end
  def children; end
  def children_duration; end
  def children_duration=(_arg0); end
  def custom_timings; end
  def depth; end
  def duration_ms; end
  def duration_ms_in_sql; end
  def move_child(child, destination); end
  def move_custom(type, custom, destination); end
  def move_sql(sql, destination); end
  def name; end
  def parent; end
  def parent=(_arg0); end
  def record_time(milliseconds = T.unsafe(nil)); end
  def sql_timings; end
  def start; end
  def start=(_arg0); end
  def start_ms; end

  class << self
    def createRoot(name, page); end
  end
end

class Rack::MiniProfiler::TimerStruct::Sql < ::Rack::MiniProfiler::TimerStruct::Base
  def initialize(query, duration_ms, page, parent, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  def parent; end
  def parent=(_arg0); end
  def report_reader_duration(elapsed_ms); end
  def trim_binds(binds); end
end

Rack::MiniProfiler::VERSION = T.let(T.unsafe(nil), String)

module Rack::MiniProfilerRails
  extend ::Rack::MiniProfilerRailsMethods

  class << self
    def create_engine; end
    def get_key(payload); end
    def initialize!(app); end
    def serves_static_assets?(app); end
    def shorten_identifier(identifier); end
    def subscribe(event, &blk); end
  end
end

class Rack::MiniProfilerRails::Railtie < ::Rails::Railtie; end

module Rack::MiniProfilerRailsMethods
  extend ::Rack::MiniProfilerRailsMethods

  def get_webpacker_assets_path; end
  def render_notification_handler(name, finish, start, name_as_description: T.unsafe(nil)); end
  def should_measure?; end
  def should_move?(child, node); end
end

Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)

class SqlPatches
  class << self
    def all_patch_files; end
    def correct_version?(required_version, klass); end
    def elapsed_time(start_time); end
    def other_patches; end
    def patch(patch_files = T.unsafe(nil)); end
    def patch_rails?; end
    def record_sql(statement, parameters = T.unsafe(nil), &block); end
    def should_measure?; end
    def sql_patches; end
  end
end
